package main

import (
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

var outputTmpl = template.Must(template.New("imports").Parse(`// Code generated by gen/imports.go. DO NOT EDIT.

package dyncapnp

// Import files collected from https://github.com/capnproto/capnproto
// Version info: {{ .Version }}
var stdImports = map[string][]byte{
{{- range $path, $content := .Files }}
	{{ $path }}: []byte({{ $content }}),
{{- end }}
}
`))

func main() {
	params := struct {
		Version string
		Files   map[string]string
	}{
		getCapnpVersion(),
		readCapnpFiles(),
	}

	out, err := os.OpenFile("imports.gen.go", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	dieOnErr(err)
	defer func() {
		err := out.Close()
		dieOnErr(err)
	}()

	err = outputTmpl.Execute(out, params)
	dieOnErr(err)
}

func getCapnpVersion() string {
	cmd := exec.Command("git", "submodule", "status", "capnproto")
	sb := strings.Builder{}
	cmd.Stdout = &sb
	err := cmd.Run()
	dieOnErr(err)

	return strings.TrimSpace(sb.String())
}

func readCapnpFiles() map[string]string {
	baseDir := filepath.Join("capnproto", "c++", "src")
	files, err := filepath.Glob(filepath.Join(baseDir, "**", "*.capnp"))
	dieOnErr(err)

	pathContentMap := make(map[string]string, len(files))
	for _, file := range files {
		p, err := filepath.Rel(baseDir, file)
		dieOnErr(err)

		b, err := ioutil.ReadFile(file)
		dieOnErr(err)

		pathContentMap[strconv.Quote(p)] = strconv.Quote(string(b))
	}
	return pathContentMap
}

func dieOnErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}